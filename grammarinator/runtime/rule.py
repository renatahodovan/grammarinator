# Copyright (c) 2017-2023 Renata Hodovan, Akos Kiss.
#
# Licensed under the BSD 3-Clause License
# <LICENSE.rst or https://opensource.org/licenses/BSD-3-Clause>.
# This file may not be copied, modified, or distributed except
# according to those terms.

from copy import deepcopy
from math import inf
from textwrap import indent


class RuleSize:
    """
    Size information about a grammar rule or a (sub)tree (generated based on a
    grammar rule), expressed using different metrics (both vertical and
    horizontal).

    This class can be used to describe various size-related concepts, e.g.:

      - The minimum depth of derivation of a grammar rule and the minimum
        number of tokens generated by a grammar rule.
      - The actual depth of derivation of a grammar rule and the actual
        number of tokens generated by a grammar rule.
      - The maximum allowed depth of derivation in a tree and the maximum number
        of tokens allowed in a tree.
      - The depth of derivation reaching a node from the root of the tree and
        the number of tokens in the tree outside the subtree of the node.

    The class supports additive arithmetics (``+``, ``+=``, ``-``, ``-=``) and
    comparisons (``==``, ``<=``, ``<``). Note, however, that the type is not
    totally but partially ordered, i.e., a size object is less than another size
    object iff all its metrics compare less than the corresponding metrics of
    the other size object.
    """

    def __init__(self, depth=0, tokens=0):
        """
        :param int or float depth: Derivation length (default: 0).
        :param int or float tokens: Token count (default: 0).

        :ivar int or float depth: Derivation length.
        :ivar int or float tokens: Token count.

        :cvar RuleSize max: All size metrics set to ``inf``.
        """
        self.depth = depth
        self.tokens = tokens

    def __add__(self, other):
        return RuleSize(depth=self.depth + other.depth, tokens=self.tokens + other.tokens)

    def __iadd__(self, other):
        self.depth += other.depth
        self.tokens += other.tokens

    def __sub__(self, other):
        return RuleSize(depth=self.depth - other.depth, tokens=self.tokens - other.tokens)

    def __isub__(self, other):
        self.depth -= other.depth
        self.tokens -= other.tokens

    def __eq__(self, other):
        return self.depth == other.depth and self.tokens == other.tokens

    def __le__(self, other):
        # This defines a partial order (i.e., reflexive, antisymmetric, and transitive).
        # Not every pair of objects are comparable.
        return self.depth <= other.depth and self.tokens <= other.tokens

    def __lt__(self, other):
        # This defines a strict partial order (i.e., irreflexive, asymmetric, and transitive).
        # Not every pair of objects are comparable.
        return self.depth < other.depth and self.tokens < other.tokens

    def __repr__(self):
        return f'{self.__class__.__name__}(depth={self.depth!r}, tokens={self.tokens!r})'


RuleSize.max = RuleSize(inf, inf)


class Rule:
    """
    Abstract base class of tree nodes.

    Tree nodes support deep copying via :func:`copy.deepcopy` (but no shallow
    copying via :func:`copy.copy`). A deep copy of a node is the copy of the
    whole subtree rooted at that node. However, the parent of a copy node is
    always None, even if the original node had a parent.

    Tree nodes support various string representations:

    - The "informal" representation of a node consists of the concatenation of
      the string contents of all tokens found in the tree rooted at the node in
      depth-first order. No extra whitespace is inserted for separation.
    - The "official" representation of a node is an (almost) valid Python
      expression to recreate the tree rooted at the node. If the node has any
      children, the representation consists of multiple lines.
    - The "debug" representation of a node is a multi-line string with the most
      important attributes of the tree rooted at the node, using vertical bars
      for visual guidance.

    The builtins :class:`str` and :func:`repr` can be used to compute the
    "informal" and "official" representations, respectively, while
    :func:`format` can produce all of the above. When string formatting is used,
    the following format specifiers are recognized:

    ================= ==========================
    Specifier         Meaning
    ================= ==========================
    ``''`` or ``'s'`` "Informal" representation.
    ``'r'``           "Official" representation.
    ``'|'``           "Debug" representation.
    ================= ==========================

    Thus, if ``n`` is a node, the following expressions give equivalent results:

    - ``str(n)``, ``f'{n}'``, ``f'{n!s}'``, ``f'{n:s}'``,
      ``'{}'.format(n)``, ``'{!s}'.format(n)``, and ``'{:s}'.format(n)``
    - ``repr(n)``, ``f'{n!r}'``, ``f'{n:r}'``, ``'{!r}'.format(n)``, and
      ``'{:r}'.format(n)``
    - ``f'{n:|}'`` and ``'{:|}'.format(n)``
    """

    def __init__(self, *, name):
        """
        :param str name: Name of the node, i.e., name of the corresponding parser or lexer rule in the grammar.

        :ivar str name: Name of the node, i.e., name of the corresponding parser or lexer rule in the grammar.
        :ivar UnparserRule parent: Parent node object.
        """
        self.name = name
        self.parent = None

    @property
    def left_sibling(self):
        """
        Get the left sibling of the node if any. Return ``None`` if the node has
        no parent or is the leftmost child of its parent.

        :return: The left sibling of the current node or ``None``.
        :rtype: Rule
        """
        if not self.parent:
            return None
        self_idx = self.parent.children.index(self)
        if self_idx == 0:
            return None
        return self.parent.children[self_idx - 1]

    @property
    def right_sibling(self):
        """
        Get the right sibling of the node if any. Return ``None`` if the node
        has no parent or is the rightmost child of its parent.

        :return: The right sibling of the current node or ``None``.
        :rtype: Rule
        """
        if not self.parent:
            return None
        self_idx = self.parent.children.index(self)
        if self_idx == len(self.parent.children) - 1:
            return None
        return self.parent.children[self_idx + 1]

    @property
    def root(self):
        """
        Get the root of the node, i.e., the node at the top of the parent chain.

        :return: The root of the current node.
        :rtype: Rule
        """
        node = self
        while node.parent:
            node = node.parent
        return node

    def replace(self, node):
        """
        Replace the current node with ``node`` among its siblings.

        :param Rule node: The replacement node.
        :return: ``node``
        :rtype: Rule
        """
        node.remove()
        if self.parent and node is not self:
            self.parent.children[self.parent.children.index(self)] = node
            node.parent = self.parent
            self.parent = None
        return node

    def remove(self):
        """
        Remove the current node from its parent.
        """
        if self.parent:
            self.parent.children.remove(self)
            self.parent = None

    def _dbg_(self):
        """
        Called by :meth:`__format__` to compute the "debug" string
        representation of a node.
        """
        raise NotImplementedError()

    def __format__(self, format_spec):
        if format_spec in ['', 's']:
            return str(self)
        if format_spec == 'r':
            return repr(self)
        if format_spec == '|':
            return self._dbg_()
        raise TypeError

    def __copy__(self):
        raise TypeError('shallow copy not supported')

    def __deepcopy__(self, memo):
        raise NotImplementedError()


class ParentRule(Rule):
    """
    Abstract base class of tree nodes that can have children.
    """

    def __init__(self, *, name, children=None):
        """
        :param str name: Name of the corresponding parser rule in the grammar.
        :param list[Rule] children: Children of the rule (default: no children).

        :ivar list[Rule] children: Children of the rule.
        """
        super().__init__(name=name)
        self.children = []
        if children:
            self.add_children(children)

    @property
    def last_child(self):
        """
        Get the last child of the current node if any. Return ``None`` if the
        node has no children.
        """
        return self.children[-1] if self.children else None

    def insert_child(self, idx, node):
        """
        Insert node as child at position.

        :param int idx: Index of position to insert ``node`` at.
        :param Rule node: Node to be inserted.
        """
        if not node:
            return
        node.remove()
        self.children.insert(idx, node)
        node.parent = self

    def add_child(self, node):
        """
        Add node to the end of the list of the children.

        :param Rule node: Node to be added to children.
        """
        if node is None:
            return
        node.remove()
        self.children.append(node)
        node.parent = self

    def add_children(self, nodes):
        """
        Add mulitple nodes to the end of the list of the children.

        :param list[Rule] nodes: List of nodes to be added to children.
        """
        for node in nodes:
            self.add_child(node)

    def __iadd__(self, item):
        """
        Support for ``+=`` operation to add one or more children to the current node. An alias to
        :meth:`add_child` or :meth:`add_children` depending on the type of ``child``.

        :param Rule or list[Rule] item: The node(s) to be added as child.
        :return: The current node with extended children.
        :rtype: Rule
        """
        if isinstance(item, list):
            self.add_children(item)
        else:
            self.add_child(item)
        return self

    def __str__(self):
        return ''.join(str(child) for child in self.children)

    def __repr__(self):
        parts = [
            f'name={self.name!r}',
        ]
        if self.children:
            parts.append('children=[\n{children}\n]'.format(children=indent(',\n'.join(repr(child) for child in self.children), '  ')))
        return f'{self.__class__.__name__}({", ".join(parts)})'

    def _dbg_(self):
        return '{name}\n{children}'.format(name=self.name, children=indent('\n'.join(child._dbg_() for child in self.children), '|  '))


class UnparserRule(ParentRule):
    """
    Tree node representing a parser rule. It can have zero or more
    :class:`UnparserRule`, :class:`UnlexerRule`, :class:`UnparserRuleQuantifier`
    or :class:`UnparserRuleAlternative` children.
    """

    def __getattr__(self, item):
        # This check is needed to avoid infinite recursions when loading a tree
        # with pickle. In such cases, the loaded instance is prepared by
        # creating an empty object with the expected ``__class__`` and by
        # restoring the saved attributes (without calling ``__init__``).
        # During this operation, the ``__set_state__`` method of the target
        # class is tried to be called, if it exists. Otherwise, ``__getattr__``
        # throws an ``AttributeError``. However, if the instantiation of this
        # error object tries to access any field that is not yet added by
        # pickle, then it throws another ``AttributeError``, causing an
        # infinite recursion. Filtering for the field names, that are used
        # later in this method, eliminates the issue.
        if item in ['name', 'children']:
            raise AttributeError()

        result = [child for child in self.children if child.name == item]

        if not result:
            raise AttributeError(f'[{self.name}] No child with name {item!r} {[child.name for child in self.children]}.')

        return result[0] if len(result) == 1 else result

    def __deepcopy__(self, memo):
        return UnparserRule(name=deepcopy(self.name, memo), children=[deepcopy(child, memo) for child in self.children])


class UnlexerRule(Rule):
    """
    Tree node representing a lexer rule or token. It has a string constant set in its ``src`` field.
    """

    def __init__(self, *, name=None, src=None, size=None):
        """
        :param str name: Name of the corresponding lexer rule in the grammar.
        :param str src: String content of the lexer rule (default: "").
        :param RuleSize size: Size of the lexer rule (default: (1,1) if ``src``
            is not empty, (0,0) otherwise).

        :ivar str src: String content of the lexer rule.
        :ivar RuleSize size: Size of the lexer rule, aggregated from the
            token fragments it is composed of.
        """
        super().__init__(name=name)
        self.src = src or ''
        self.size = size or (RuleSize(depth=1, tokens=1) if src else RuleSize(depth=0, tokens=0))

    def __str__(self):
        return self.src

    def __repr__(self):
        parts = []
        if self.name:
            parts.append(f'name={self.name!r}')
        if self.src:
            parts.append(f'src={self.src!r}')
        if (self.src and self.size != RuleSize(1, 1)) or (not self.src and self.size != RuleSize(0, 0)):
            parts.append(f'size={self.size!r}')
        return f'{self.__class__.__name__}({", ".join(parts)})'

    def _dbg_(self):
        return f'{self.name or ""}{":" if self.name else ""}{self.src!r}'

    def __deepcopy__(self, memo):
        return UnlexerRule(name=deepcopy(self.name, memo), src=deepcopy(self.src, memo), size=deepcopy(self.size, memo))


class UnparserRuleQuantifier(ParentRule):
    """
    Tree node representing the root of a quantified sub-tree. It can have one
    or more :class:`UnparserRuleQuantified` children.
    """

    def __init__(self, *, idx, start, stop, children=None):
        super().__init__(name=None, children=children)
        self.idx = idx
        self.start = start
        self.stop = stop

    def __repr__(self):
        parts = [
            f'idx={self.idx}',
            f'start={self.start}',
            f'stop={self.stop}',
        ]
        if self.children:
            parts.append('children=[\n{children}\n]'.format(children=indent(',\n'.join(repr(child) for child in self.children), '  ')))
        return f'{self.__class__.__name__}({", ".join(parts)})'

    def __deepcopy__(self, memo):
        return UnparserRuleQuantifier(idx=deepcopy(self.idx, memo), start=deepcopy(self.start, memo), stop=deepcopy(self.stop, memo), children=[deepcopy(child, memo) for child in self.children])


class UnparserRuleQuantified(ParentRule):
    """
    Tree node representing a single instance of quantified sub-tree. It can
    have one or more :class:`UnparserRule`, :class:`UnlexerRule`,
    :class:`UnparserRuleQuantifier` or :class:`UnparserRuleAlternative`
    children.
    """

    def __init__(self, *, children=None):
        super().__init__(name=None, children=children)

    def __deepcopy__(self, memo):
        return UnparserRuleQuantified(children=[deepcopy(child, memo) for child in self.children])


class UnparserRuleAlternative(ParentRule):
    """
    Tree node representing a sub-tree of an alternative. It can
    have zero or more :class:`UnparserRule`, :class:`UnlexerRule`,
    :class:`UnparserRuleQuantifier` or :class:`UnparserRuleAlternative`
    children.
    """

    def __init__(self, *, alt_idx, idx, children=None):
        super().__init__(name=None, children=children)
        self.alt_idx = alt_idx
        self.idx = idx

    def __repr__(self):
        parts = [
            f'alt_idx={self.alt_idx}',
            f'idx={self.idx}',
        ]
        if self.children:
            parts.append('children=[\n{children}\n]'.format(
                children=indent(',\n'.join(repr(child) for child in self.children), '  ')))
        return f'{self.__class__.__name__}({", ".join(parts)})'

    def __deepcopy__(self, memo):
        return UnparserRuleAlternative(alt_idx=deepcopy(self.alt_idx, memo),
                                       idx=deepcopy(self.idx, memo),
                                       children=[deepcopy(child, memo) for child in self.children])

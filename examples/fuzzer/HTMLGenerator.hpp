// Generated by Grammarinator 23.7.post171+gb0bf1be4d

#ifndef GRAMMARINATOR_GENERATED_HTMLGENERATOR_HPP
#define GRAMMARINATOR_GENERATED_HTMLGENERATOR_HPP

#include <climits>
#include <map>
#include <string>
#include <vector>

#undef EOF

#include "grammarinator/runtime/Generator.hpp"

using namespace grammarinator;
using namespace grammarinator::runtime;
using namespace grammarinator::tool;

class HTMLGenerator : public Generator
{
public:
    explicit HTMLGenerator(Model* model=new DefaultModel(), const std::vector<Listener*>& listeners={}, const RuleSize& limit=RuleSize::max()) : Generator(model, listeners, limit) {}


    Rule* HTML_COMMENT(Rule *parent = nullptr) {
        UnlexerRuleContext rule(this, "HTML_COMMENT", parent);
        Rule* current = rule.current();
        static_cast<UnlexerRule*>(current)->src += "<!--";
        {
            QuantifierContext quant0(rule, 0, 0, INT_MAX, HTMLGenerator::_quant_sizes[0], 0);
            while (quant0()) {
                {
                    QuantifiedContext quantified(rule);
                    current = rule.current();
                    static_cast<UnlexerRule*>(current)->src += _model->charset(current, 0, HTMLGenerator::_charsets[0]);
                }
            }
        }
        current = rule.current();
        static_cast<UnlexerRule*>(current)->src += "-->";
        return current;
    }

    Rule* HTML_CONDITIONAL_COMMENT(Rule *parent = nullptr) {
        UnlexerRuleContext rule(this, "HTML_CONDITIONAL_COMMENT", parent);
        Rule* current = rule.current();
        static_cast<UnlexerRule*>(current)->src += "<![";
        {
            QuantifierContext quant0(rule, 0, 0, INT_MAX, HTMLGenerator::_quant_sizes[0], 0);
            while (quant0()) {
                {
                    QuantifiedContext quantified(rule);
                    current = rule.current();
                    static_cast<UnlexerRule*>(current)->src += _model->charset(current, 0, HTMLGenerator::_charsets[0]);
                }
            }
        }
        current = rule.current();
        static_cast<UnlexerRule*>(current)->src += "]>";
        return current;
    }

    Rule* XML_DECLARATION(Rule *parent = nullptr) {
        UnlexerRuleContext rule(this, "XML_DECLARATION", parent);
        Rule* current = rule.current();
        static_cast<UnlexerRule*>(current)->src += "<?xml";
        {
            QuantifierContext quant0(rule, 0, 0, INT_MAX, HTMLGenerator::_quant_sizes[0], 0);
            while (quant0()) {
                {
                    QuantifiedContext quantified(rule);
                    current = rule.current();
                    static_cast<UnlexerRule*>(current)->src += _model->charset(current, 0, HTMLGenerator::_charsets[0]);
                }
            }
        }
        current = rule.current();
        static_cast<UnlexerRule*>(current)->src += ">";
        return current;
    }

    Rule* CDATA(Rule *parent = nullptr) {
        UnlexerRuleContext rule(this, "CDATA", parent);
        Rule* current = rule.current();
        static_cast<UnlexerRule*>(current)->src += "<![CDATA[";
        {
            QuantifierContext quant0(rule, 0, 0, INT_MAX, HTMLGenerator::_quant_sizes[0], 0);
            while (quant0()) {
                {
                    QuantifiedContext quantified(rule);
                    current = rule.current();
                    static_cast<UnlexerRule*>(current)->src += _model->charset(current, 0, HTMLGenerator::_charsets[0]);
                }
            }
        }
        current = rule.current();
        static_cast<UnlexerRule*>(current)->src += "]]>";
        return current;
    }

    Rule* DTD(Rule *parent = nullptr) {
        UnlexerRuleContext rule(this, "DTD", parent);
        Rule* current = rule.current();
        static_cast<UnlexerRule*>(current)->src += "<!";
        {
            QuantifierContext quant0(rule, 0, 0, INT_MAX, HTMLGenerator::_quant_sizes[0], 0);
            while (quant0()) {
                {
                    QuantifiedContext quantified(rule);
                    current = rule.current();
                    static_cast<UnlexerRule*>(current)->src += _model->charset(current, 0, HTMLGenerator::_charsets[0]);
                }
            }
        }
        current = rule.current();
        static_cast<UnlexerRule*>(current)->src += ">";
        return current;
    }

    Rule* SCRIPTLET(Rule *parent = nullptr) {
        UnlexerRuleContext rule(this, "SCRIPTLET", parent);
        Rule* current = rule.current();
        {
            AlternationContext alt0(rule, 0, HTMLGenerator::_alt_sizes[0], 0, HTMLGenerator::_alt_conds[0]);
            current = rule.current();
            size_t choice0 = alt0();
            switch (choice0) {
                case 0:
                    static_cast<UnlexerRule*>(current)->src += "<?";
                    {
                        QuantifierContext quant0(rule, 0, 0, INT_MAX, HTMLGenerator::_quant_sizes[0], 0);
                        while (quant0()) {
                            {
                                QuantifiedContext quantified(rule);
                                current = rule.current();
                                static_cast<UnlexerRule*>(current)->src += _model->charset(current, 0, HTMLGenerator::_charsets[0]);
                            }
                        }
                    }
                    current = rule.current();
                    static_cast<UnlexerRule*>(current)->src += "?>";
                    break;
                case 1:
                    static_cast<UnlexerRule*>(current)->src += "<%";
                    {
                        QuantifierContext quant1(rule, 1, 0, INT_MAX, HTMLGenerator::_quant_sizes[0], 0);
                        while (quant1()) {
                            {
                                QuantifiedContext quantified(rule);
                                current = rule.current();
                                static_cast<UnlexerRule*>(current)->src += _model->charset(current, 1, HTMLGenerator::_charsets[0]);
                            }
                        }
                    }
                    current = rule.current();
                    static_cast<UnlexerRule*>(current)->src += "%>";
                    break;
            }
        }
        current = rule.current();
        return current;
    }

    Rule* SEA_WS(Rule *parent = nullptr) {
        UnlexerRuleContext rule(this, "SEA_WS", parent);
        Rule* current = rule.current();
        {
            QuantifierContext quant0(rule, 0, 1, INT_MAX, HTMLGenerator::_quant_sizes[0], 0);
            while (quant0()) {
                {
                    QuantifiedContext quantified(rule);
                    current = rule.current();
                    {
                        AlternationContext alt0(rule, 0, HTMLGenerator::_alt_sizes[1], 0, HTMLGenerator::_alt_conds[1]);
                        current = rule.current();
                        size_t choice0 = alt0();
                        switch (choice0) {
                            case 0:
                                static_cast<UnlexerRule*>(current)->src += " ";
                                break;
                            case 1:
                                static_cast<UnlexerRule*>(current)->src += "\t";
                                break;
                            case 2:
                                {
                                    QuantifierContext quant1(rule, 1, 0, 1, HTMLGenerator::_quant_sizes[0], 0);
                                    while (quant1()) {
                                        {
                                            QuantifiedContext quantified(rule);
                                            current = rule.current();
                                            static_cast<UnlexerRule*>(current)->src += "\r";
                                        }
                                    }
                                }
                                current = rule.current();
                                static_cast<UnlexerRule*>(current)->src += "\n";
                                break;
                        }
                    }
                    current = rule.current();
                }
            }
        }
        current = rule.current();
        return current;
    }

    Rule* SCRIPT_OPEN(Rule *parent = nullptr) {
        UnlexerRuleContext rule(this, "SCRIPT_OPEN", parent);
        Rule* current = rule.current();
        static_cast<UnlexerRule*>(current)->src += "<script";
        {
            QuantifierContext quant0(rule, 0, 0, INT_MAX, HTMLGenerator::_quant_sizes[0], 0);
            while (quant0()) {
                {
                    QuantifiedContext quantified(rule);
                    current = rule.current();
                    static_cast<UnlexerRule*>(current)->src += _model->charset(current, 0, HTMLGenerator::_charsets[0]);
                }
            }
        }
        current = rule.current();
        static_cast<UnlexerRule*>(current)->src += ">";
        return current;
    }

    Rule* STYLE_OPEN(Rule *parent = nullptr) {
        UnlexerRuleContext rule(this, "STYLE_OPEN", parent);
        Rule* current = rule.current();
        static_cast<UnlexerRule*>(current)->src += "<style";
        {
            QuantifierContext quant0(rule, 0, 0, INT_MAX, HTMLGenerator::_quant_sizes[0], 0);
            while (quant0()) {
                {
                    QuantifiedContext quantified(rule);
                    current = rule.current();
                    static_cast<UnlexerRule*>(current)->src += _model->charset(current, 0, HTMLGenerator::_charsets[0]);
                }
            }
        }
        current = rule.current();
        static_cast<UnlexerRule*>(current)->src += ">";
        return current;
    }

    Rule* TAG_OPEN(Rule *parent = nullptr) {
        UnlexerRuleContext rule(this, "TAG_OPEN", parent, true);
        Rule* current = rule.current();
        static_cast<UnlexerRule*>(current)->src += "<";
        return current;
    }

    Rule* HTML_TEXT(Rule *parent = nullptr) {
        UnlexerRuleContext rule(this, "HTML_TEXT", parent);
        Rule* current = rule.current();
        {
            QuantifierContext quant0(rule, 0, 1, INT_MAX, HTMLGenerator::_quant_sizes[0], 0);
            while (quant0()) {
                {
                    QuantifiedContext quantified(rule);
                    current = rule.current();
                    static_cast<UnlexerRule*>(current)->src += _model->charset(current, 0, HTMLGenerator::_charsets[1]);
                }
            }
        }
        current = rule.current();
        return current;
    }

    Rule* TAG_CLOSE(Rule *parent = nullptr) {
        UnlexerRuleContext rule(this, "TAG_CLOSE", parent, true);
        Rule* current = rule.current();
        static_cast<UnlexerRule*>(current)->src += ">";
        return current;
    }

    Rule* TAG_SLASH_CLOSE(Rule *parent = nullptr) {
        UnlexerRuleContext rule(this, "TAG_SLASH_CLOSE", parent, true);
        Rule* current = rule.current();
        static_cast<UnlexerRule*>(current)->src += "/>";
        return current;
    }

    Rule* TAG_SLASH(Rule *parent = nullptr) {
        UnlexerRuleContext rule(this, "TAG_SLASH", parent, true);
        Rule* current = rule.current();
        static_cast<UnlexerRule*>(current)->src += "/";
        return current;
    }

    Rule* TAG_EQUALS(Rule *parent = nullptr) {
        UnlexerRuleContext rule(this, "TAG_EQUALS", parent, true);
        Rule* current = rule.current();
        static_cast<UnlexerRule*>(current)->src += "=";
        return current;
    }

    Rule* TAG_NAME(Rule *parent = nullptr) {
        UnlexerRuleContext rule(this, "TAG_NAME", parent);
        Rule* current = rule.current();
        TAG_NameStartChar(current);
        {
            QuantifierContext quant0(rule, 0, 0, INT_MAX, HTMLGenerator::_quant_sizes[1], 0);
            while (quant0()) {
                {
                    QuantifiedContext quantified(rule);
                    current = rule.current();
                    TAG_NameChar(current);
                }
            }
        }
        current = rule.current();
        return current;
    }

    Rule* TAG_WHITESPACE(Rule *parent = nullptr) {
        UnlexerRuleContext rule(this, "TAG_WHITESPACE", parent);
        Rule* current = rule.current();
        static_cast<UnlexerRule*>(current)->src += _model->charset(current, 0, HTMLGenerator::_charsets[2]);
        return current;
    }

    Rule* HEXDIGIT(Rule *parent = nullptr) {
        UnlexerRuleContext rule(this, "HEXDIGIT", parent);
        Rule* current = rule.current();
        static_cast<UnlexerRule*>(current)->src += _model->charset(current, 0, HTMLGenerator::_charsets[3]);
        return current;
    }

    Rule* DIGIT(Rule *parent = nullptr) {
        UnlexerRuleContext rule(this, "DIGIT", parent);
        Rule* current = rule.current();
        static_cast<UnlexerRule*>(current)->src += _model->charset(current, 0, HTMLGenerator::_charsets[4]);
        return current;
    }

    Rule* TAG_NameChar(Rule *parent = nullptr) {
        UnlexerRuleContext rule(this, "TAG_NameChar", parent);
        Rule* current = rule.current();
        {
            AlternationContext alt0(rule, 0, HTMLGenerator::_alt_sizes[2], 0, HTMLGenerator::_alt_conds[2]);
            current = rule.current();
            size_t choice0 = alt0();
            switch (choice0) {
                case 0:
                    TAG_NameStartChar(current);
                    break;
                case 1:
                    static_cast<UnlexerRule*>(current)->src += "-";
                    break;
                case 2:
                    static_cast<UnlexerRule*>(current)->src += "_";
                    break;
                case 3:
                    static_cast<UnlexerRule*>(current)->src += ".";
                    break;
                case 4:
                    DIGIT(current);
                    break;
                case 5:
                    static_cast<UnlexerRule*>(current)->src += "\xb7";
                    break;
                case 6:
                    static_cast<UnlexerRule*>(current)->src += _model->charset(current, 0, HTMLGenerator::_charsets[5]);
                    break;
                case 7:
                    static_cast<UnlexerRule*>(current)->src += _model->charset(current, 1, HTMLGenerator::_charsets[6]);
                    break;
            }
        }
        current = rule.current();
        return current;
    }

    Rule* TAG_NameStartChar(Rule *parent = nullptr) {
        UnlexerRuleContext rule(this, "TAG_NameStartChar", parent);
        Rule* current = rule.current();
        {
            AlternationContext alt0(rule, 0, HTMLGenerator::_alt_sizes[3], 0, HTMLGenerator::_alt_conds[3]);
            current = rule.current();
            size_t choice0 = alt0();
            switch (choice0) {
                case 0:
                    static_cast<UnlexerRule*>(current)->src += _model->charset(current, 0, HTMLGenerator::_charsets[7]);
                    break;
                case 1:
                    static_cast<UnlexerRule*>(current)->src += _model->charset(current, 1, HTMLGenerator::_charsets[8]);
                    break;
                case 2:
                    static_cast<UnlexerRule*>(current)->src += _model->charset(current, 2, HTMLGenerator::_charsets[9]);
                    break;
                case 3:
                    static_cast<UnlexerRule*>(current)->src += _model->charset(current, 3, HTMLGenerator::_charsets[10]);
                    break;
                case 4:
                    static_cast<UnlexerRule*>(current)->src += _model->charset(current, 4, HTMLGenerator::_charsets[11]);
                    break;
                case 5:
                    static_cast<UnlexerRule*>(current)->src += _model->charset(current, 5, HTMLGenerator::_charsets[12]);
                    break;
            }
        }
        current = rule.current();
        return current;
    }

    Rule* SCRIPT_BODY(Rule *parent = nullptr) {
        UnlexerRuleContext rule(this, "SCRIPT_BODY", parent);
        Rule* current = rule.current();
        {
            QuantifierContext quant0(rule, 0, 0, INT_MAX, HTMLGenerator::_quant_sizes[0], 0);
            while (quant0()) {
                {
                    QuantifiedContext quantified(rule);
                    current = rule.current();
                    static_cast<UnlexerRule*>(current)->src += _model->charset(current, 0, HTMLGenerator::_charsets[0]);
                }
            }
        }
        current = rule.current();
        static_cast<UnlexerRule*>(current)->src += "</script>";
        return current;
    }

    Rule* SCRIPT_SHORT_BODY(Rule *parent = nullptr) {
        UnlexerRuleContext rule(this, "SCRIPT_SHORT_BODY", parent);
        Rule* current = rule.current();
        {
            QuantifierContext quant0(rule, 0, 0, INT_MAX, HTMLGenerator::_quant_sizes[0], 0);
            while (quant0()) {
                {
                    QuantifiedContext quantified(rule);
                    current = rule.current();
                    static_cast<UnlexerRule*>(current)->src += _model->charset(current, 0, HTMLGenerator::_charsets[0]);
                }
            }
        }
        current = rule.current();
        static_cast<UnlexerRule*>(current)->src += "</>";
        return current;
    }

    Rule* STYLE_BODY(Rule *parent = nullptr) {
        UnlexerRuleContext rule(this, "STYLE_BODY", parent, true);
        Rule* current = rule.current();
        static_cast<UnlexerRule*>(current)->src += "</style>";
        return current;
    }

    Rule* STYLE_SHORT_BODY(Rule *parent = nullptr) {
        UnlexerRuleContext rule(this, "STYLE_SHORT_BODY", parent, true);
        Rule* current = rule.current();
        static_cast<UnlexerRule*>(current)->src += "</>";
        return current;
    }

    Rule* ATTVALUE_VALUE(Rule *parent = nullptr) {
        UnlexerRuleContext rule(this, "ATTVALUE_VALUE", parent);
        Rule* current = rule.current();
        {
            QuantifierContext quant0(rule, 0, 0, INT_MAX, HTMLGenerator::_quant_sizes[0], 2);
            while (quant0()) {
                {
                    QuantifiedContext quantified(rule);
                    current = rule.current();
                    static_cast<UnlexerRule*>(current)->src += _model->charset(current, 0, HTMLGenerator::_charsets[13]);
                }
            }
        }
        current = rule.current();
        ATTRIBUTE(current);
        return current;
    }

    Rule* ATTRIBUTE(Rule *parent = nullptr) {
        UnlexerRuleContext rule(this, "ATTRIBUTE", parent);
        Rule* current = rule.current();
        {
            AlternationContext alt0(rule, 0, HTMLGenerator::_alt_sizes[4], 0, HTMLGenerator::_alt_conds[4]);
            current = rule.current();
            std::vector<RuleFn> options{ &HTMLGenerator::DOUBLE_QUOTE_STRING, &HTMLGenerator::SINGLE_QUOTE_STRING, &HTMLGenerator::ATTCHARS, &HTMLGenerator::HEXCHARS, &HTMLGenerator::DECCHARS };
            RuleFn fn = options[alt0()];
            (this->*fn)(current);
        }
        current = rule.current();
        return current;
    }

    Rule* ATTCHAR(Rule *parent = nullptr) {
        UnlexerRuleContext rule(this, "ATTCHAR", parent);
        Rule* current = rule.current();
        {
            AlternationContext alt0(rule, 0, HTMLGenerator::_alt_sizes[5], 0, HTMLGenerator::_alt_conds[5]);
            current = rule.current();
            size_t choice0 = alt0();
            switch (choice0) {
                case 0:
                    static_cast<UnlexerRule*>(current)->src += "-";
                    break;
                case 1:
                    static_cast<UnlexerRule*>(current)->src += "_";
                    break;
                case 2:
                    static_cast<UnlexerRule*>(current)->src += ".";
                    break;
                case 3:
                    static_cast<UnlexerRule*>(current)->src += "/";
                    break;
                case 4:
                    static_cast<UnlexerRule*>(current)->src += "+";
                    break;
                case 5:
                    static_cast<UnlexerRule*>(current)->src += ",";
                    break;
                case 6:
                    static_cast<UnlexerRule*>(current)->src += "?";
                    break;
                case 7:
                    static_cast<UnlexerRule*>(current)->src += "=";
                    break;
                case 8:
                    static_cast<UnlexerRule*>(current)->src += ":";
                    break;
                case 9:
                    static_cast<UnlexerRule*>(current)->src += ";";
                    break;
                case 10:
                    static_cast<UnlexerRule*>(current)->src += "#";
                    break;
                case 11:
                    static_cast<UnlexerRule*>(current)->src += _model->charset(current, 0, HTMLGenerator::_charsets[14]);
                    break;
            }
        }
        current = rule.current();
        return current;
    }

    Rule* ATTCHARS(Rule *parent = nullptr) {
        UnlexerRuleContext rule(this, "ATTCHARS", parent);
        Rule* current = rule.current();
        {
            QuantifierContext quant0(rule, 0, 1, INT_MAX, HTMLGenerator::_quant_sizes[1], 0);
            while (quant0()) {
                {
                    QuantifiedContext quantified(rule);
                    current = rule.current();
                    ATTCHAR(current);
                }
            }
        }
        current = rule.current();
        {
            QuantifierContext quant1(rule, 1, 0, 1, HTMLGenerator::_quant_sizes[0], 0);
            while (quant1()) {
                {
                    QuantifiedContext quantified(rule);
                    current = rule.current();
                    static_cast<UnlexerRule*>(current)->src += " ";
                }
            }
        }
        current = rule.current();
        return current;
    }

    Rule* HEXCHARS(Rule *parent = nullptr) {
        UnlexerRuleContext rule(this, "HEXCHARS", parent);
        Rule* current = rule.current();
        static_cast<UnlexerRule*>(current)->src += "#";
        {
            QuantifierContext quant0(rule, 0, 1, INT_MAX, HTMLGenerator::_quant_sizes[0], 0);
            while (quant0()) {
                {
                    QuantifiedContext quantified(rule);
                    current = rule.current();
                    static_cast<UnlexerRule*>(current)->src += _model->charset(current, 0, HTMLGenerator::_charsets[3]);
                }
            }
        }
        current = rule.current();
        return current;
    }

    Rule* DECCHARS(Rule *parent = nullptr) {
        UnlexerRuleContext rule(this, "DECCHARS", parent);
        Rule* current = rule.current();
        {
            QuantifierContext quant0(rule, 0, 1, INT_MAX, HTMLGenerator::_quant_sizes[0], 0);
            while (quant0()) {
                {
                    QuantifiedContext quantified(rule);
                    current = rule.current();
                    static_cast<UnlexerRule*>(current)->src += _model->charset(current, 0, HTMLGenerator::_charsets[4]);
                }
            }
        }
        current = rule.current();
        {
            QuantifierContext quant1(rule, 1, 0, 1, HTMLGenerator::_quant_sizes[0], 0);
            while (quant1()) {
                {
                    QuantifiedContext quantified(rule);
                    current = rule.current();
                    static_cast<UnlexerRule*>(current)->src += "%";
                }
            }
        }
        current = rule.current();
        return current;
    }

    Rule* DOUBLE_QUOTE_STRING(Rule *parent = nullptr) {
        UnlexerRuleContext rule(this, "DOUBLE_QUOTE_STRING", parent);
        Rule* current = rule.current();
        static_cast<UnlexerRule*>(current)->src += "\"";
        {
            QuantifierContext quant0(rule, 0, 0, INT_MAX, HTMLGenerator::_quant_sizes[0], 0);
            while (quant0()) {
                {
                    QuantifiedContext quantified(rule);
                    current = rule.current();
                    static_cast<UnlexerRule*>(current)->src += _model->charset(current, 0, HTMLGenerator::_charsets[15]);
                }
            }
        }
        current = rule.current();
        static_cast<UnlexerRule*>(current)->src += "\"";
        return current;
    }

    Rule* SINGLE_QUOTE_STRING(Rule *parent = nullptr) {
        UnlexerRuleContext rule(this, "SINGLE_QUOTE_STRING", parent);
        Rule* current = rule.current();
        static_cast<UnlexerRule*>(current)->src += "\'";
        {
            QuantifierContext quant0(rule, 0, 0, INT_MAX, HTMLGenerator::_quant_sizes[0], 0);
            while (quant0()) {
                {
                    QuantifiedContext quantified(rule);
                    current = rule.current();
                    static_cast<UnlexerRule*>(current)->src += _model->charset(current, 0, HTMLGenerator::_charsets[16]);
                }
            }
        }
        current = rule.current();
        static_cast<UnlexerRule*>(current)->src += "\'";
        return current;
    }

    Rule* htmlDocument(Rule *parent = nullptr) {
        UnparserRuleContext rule(this, "htmlDocument", parent);
        Rule* current = rule.current();
        {
            QuantifierContext quant0(rule, 0, 0, INT_MAX, HTMLGenerator::_quant_sizes[1], 0);
            while (quant0()) {
                {
                    QuantifiedContext quantified(rule);
                    current = rule.current();
                    {
                        AlternationContext alt0(rule, 0, HTMLGenerator::_alt_sizes[6], 0, HTMLGenerator::_alt_conds[0]);
                        current = rule.current();
                        std::vector<RuleFn> options{ &HTMLGenerator::scriptlet, &HTMLGenerator::SEA_WS };
                        RuleFn fn = options[alt0()];
                        (this->*fn)(current);
                    }
                    current = rule.current();
                }
            }
        }
        current = rule.current();
        {
            QuantifierContext quant1(rule, 1, 0, 1, HTMLGenerator::_quant_sizes[2], 0);
            while (quant1()) {
                {
                    QuantifiedContext quantified(rule);
                    current = rule.current();
                    xml(current);
                }
            }
        }
        current = rule.current();
        {
            QuantifierContext quant2(rule, 2, 0, INT_MAX, HTMLGenerator::_quant_sizes[1], 0);
            while (quant2()) {
                {
                    QuantifiedContext quantified(rule);
                    current = rule.current();
                    {
                        AlternationContext alt1(rule, 1, HTMLGenerator::_alt_sizes[6], 0, HTMLGenerator::_alt_conds[0]);
                        current = rule.current();
                        std::vector<RuleFn> options{ &HTMLGenerator::scriptlet, &HTMLGenerator::SEA_WS };
                        RuleFn fn = options[alt1()];
                        (this->*fn)(current);
                    }
                    current = rule.current();
                }
            }
        }
        current = rule.current();
        {
            QuantifierContext quant3(rule, 3, 0, 1, HTMLGenerator::_quant_sizes[2], 0);
            while (quant3()) {
                {
                    QuantifiedContext quantified(rule);
                    current = rule.current();
                    dtd(current);
                }
            }
        }
        current = rule.current();
        {
            QuantifierContext quant4(rule, 4, 0, INT_MAX, HTMLGenerator::_quant_sizes[1], 0);
            while (quant4()) {
                {
                    QuantifiedContext quantified(rule);
                    current = rule.current();
                    {
                        AlternationContext alt2(rule, 2, HTMLGenerator::_alt_sizes[6], 0, HTMLGenerator::_alt_conds[0]);
                        current = rule.current();
                        std::vector<RuleFn> options{ &HTMLGenerator::scriptlet, &HTMLGenerator::SEA_WS };
                        RuleFn fn = options[alt2()];
                        (this->*fn)(current);
                    }
                    current = rule.current();
                }
            }
        }
        current = rule.current();
        {
            QuantifierContext quant5(rule, 5, 0, INT_MAX, HTMLGenerator::_quant_sizes[3], 0);
            while (quant5()) {
                {
                    QuantifiedContext quantified(rule);
                    current = rule.current();
                    htmlElements(current);
                }
            }
        }
        current = rule.current();
        return current;
    }

    Rule* htmlElements(Rule *parent = nullptr) {
        UnparserRuleContext rule(this, "htmlElements", parent);
        Rule* current = rule.current();
        {
            QuantifierContext quant0(rule, 0, 0, INT_MAX, HTMLGenerator::_quant_sizes[2], 1);
            while (quant0()) {
                {
                    QuantifiedContext quantified(rule);
                    current = rule.current();
                    htmlMisc(current);
                }
            }
        }
        current = rule.current();
        htmlElement(current);
        {
            QuantifierContext quant1(rule, 1, 0, INT_MAX, HTMLGenerator::_quant_sizes[2], 0);
            while (quant1()) {
                {
                    QuantifiedContext quantified(rule);
                    current = rule.current();
                    htmlMisc(current);
                }
            }
        }
        current = rule.current();
        return current;
    }

    Rule* htmlElement(Rule *parent = nullptr) {
        UnparserRuleContext rule(this, "htmlElement", parent);
        Rule* current = rule.current();
        {
            AlternationContext alt0(rule, 0, HTMLGenerator::_alt_sizes[7], 0, HTMLGenerator::_alt_conds[3]);
            current = rule.current();
            size_t choice0 = alt0();
            switch (choice0) {
                case 0:
                    _reserve(8, this, &HTMLGenerator::TAG_OPEN, current);
                    _reserve(6, this, &HTMLGenerator::htmlTagName, current);
                    {
                        QuantifierContext quant0(rule, 0, 0, INT_MAX, HTMLGenerator::_quant_sizes[4], 6);
                        while (quant0()) {
                            {
                                QuantifiedContext quantified(rule);
                                current = rule.current();
                                htmlAttribute(current);
                            }
                        }
                    }
                    current = rule.current();
                    _reserve(5, this, &HTMLGenerator::TAG_CLOSE, current);
                    _reserve(5, this, &HTMLGenerator::htmlContent, current);
                    _reserve(4, this, &HTMLGenerator::TAG_OPEN, current);
                    _reserve(3, this, &HTMLGenerator::TAG_SLASH, current);
                    _reserve(1, this, &HTMLGenerator::htmlTagName, current);
                    TAG_CLOSE(current);
                    break;
                case 1:
                    _reserve(3, this, &HTMLGenerator::TAG_OPEN, current);
                    _reserve(1, this, &HTMLGenerator::htmlTagName, current);
                    {
                        QuantifierContext quant1(rule, 1, 0, INT_MAX, HTMLGenerator::_quant_sizes[4], 1);
                        while (quant1()) {
                            {
                                QuantifiedContext quantified(rule);
                                current = rule.current();
                                htmlAttribute(current);
                            }
                        }
                    }
                    current = rule.current();
                    TAG_SLASH_CLOSE(current);
                    break;
                case 2:
                    _reserve(3, this, &HTMLGenerator::TAG_OPEN, current);
                    _reserve(1, this, &HTMLGenerator::htmlTagName, current);
                    {
                        QuantifierContext quant2(rule, 2, 0, INT_MAX, HTMLGenerator::_quant_sizes[4], 1);
                        while (quant2()) {
                            {
                                QuantifiedContext quantified(rule);
                                current = rule.current();
                                htmlAttribute(current);
                            }
                        }
                    }
                    current = rule.current();
                    TAG_CLOSE(current);
                    break;
                case 3:
                    scriptlet(current);
                    break;
                case 4:
                    script(current);
                    break;
                case 5:
                    style(current);
                    break;
            }
        }
        current = rule.current();
        return current;
    }

    Rule* htmlContent(Rule *parent = nullptr) {
        UnparserRuleContext rule(this, "htmlContent", parent);
        Rule* current = rule.current();
        {
            QuantifierContext quant0(rule, 0, 0, 1, HTMLGenerator::_quant_sizes[2], 0);
            while (quant0()) {
                {
                    QuantifiedContext quantified(rule);
                    current = rule.current();
                    htmlChardata(current);
                }
            }
        }
        current = rule.current();
        {
            QuantifierContext quant1(rule, 1, 0, INT_MAX, HTMLGenerator::_quant_sizes[2], 0);
            while (quant1()) {
                {
                    QuantifiedContext quantified(rule);
                    current = rule.current();
                    {
                        AlternationContext alt0(rule, 0, HTMLGenerator::_alt_sizes[8], 0, HTMLGenerator::_alt_conds[1]);
                        current = rule.current();
                        std::vector<RuleFn> options{ &HTMLGenerator::htmlElement, &HTMLGenerator::xhtmlCDATA, &HTMLGenerator::htmlComment };
                        RuleFn fn = options[alt0()];
                        (this->*fn)(current);
                    }
                    current = rule.current();
                    {
                        QuantifierContext quant2(rule, 2, 0, 1, HTMLGenerator::_quant_sizes[2], 0);
                        while (quant2()) {
                            {
                                QuantifiedContext quantified(rule);
                                current = rule.current();
                                htmlChardata(current);
                            }
                        }
                    }
                    current = rule.current();
                }
            }
        }
        current = rule.current();
        return current;
    }

    Rule* htmlAttribute(Rule *parent = nullptr) {
        UnparserRuleContext rule(this, "htmlAttribute", parent);
        Rule* current = rule.current();
        {
            AlternationContext alt0(rule, 0, HTMLGenerator::_alt_sizes[9], 0, HTMLGenerator::_alt_conds[0]);
            current = rule.current();
            size_t choice0 = alt0();
            switch (choice0) {
                case 0:
                    _reserve(4, this, &HTMLGenerator::htmlAttributeName, current);
                    _reserve(3, this, &HTMLGenerator::TAG_EQUALS, current);
                    htmlAttributeValue(current);
                    break;
                case 1:
                    htmlAttributeName(current);
                    break;
            }
        }
        current = rule.current();
        return current;
    }

    Rule* htmlAttributeName(Rule *parent = nullptr) {
        UnparserRuleContext rule(this, "htmlAttributeName", parent);
        Rule* current = rule.current();
        TAG_NAME(current);
        return current;
    }

    Rule* htmlAttributeValue(Rule *parent = nullptr) {
        UnparserRuleContext rule(this, "htmlAttributeValue", parent);
        Rule* current = rule.current();
        ATTVALUE_VALUE(current);
        return current;
    }

    Rule* htmlTagName(Rule *parent = nullptr) {
        UnparserRuleContext rule(this, "htmlTagName", parent);
        Rule* current = rule.current();
        TAG_NAME(current);
        return current;
    }

    Rule* htmlChardata(Rule *parent = nullptr) {
        UnparserRuleContext rule(this, "htmlChardata", parent);
        Rule* current = rule.current();
        {
            AlternationContext alt0(rule, 0, HTMLGenerator::_alt_sizes[10], 0, HTMLGenerator::_alt_conds[0]);
            current = rule.current();
            std::vector<RuleFn> options{ &HTMLGenerator::HTML_TEXT, &HTMLGenerator::SEA_WS };
            RuleFn fn = options[alt0()];
            (this->*fn)(current);
        }
        current = rule.current();
        return current;
    }

    Rule* htmlMisc(Rule *parent = nullptr) {
        UnparserRuleContext rule(this, "htmlMisc", parent);
        Rule* current = rule.current();
        {
            AlternationContext alt0(rule, 0, HTMLGenerator::_alt_sizes[6], 0, HTMLGenerator::_alt_conds[0]);
            current = rule.current();
            std::vector<RuleFn> options{ &HTMLGenerator::htmlComment, &HTMLGenerator::SEA_WS };
            RuleFn fn = options[alt0()];
            (this->*fn)(current);
        }
        current = rule.current();
        return current;
    }

    Rule* htmlComment(Rule *parent = nullptr) {
        UnparserRuleContext rule(this, "htmlComment", parent);
        Rule* current = rule.current();
        {
            AlternationContext alt0(rule, 0, HTMLGenerator::_alt_sizes[10], 0, HTMLGenerator::_alt_conds[0]);
            current = rule.current();
            std::vector<RuleFn> options{ &HTMLGenerator::HTML_COMMENT, &HTMLGenerator::HTML_CONDITIONAL_COMMENT };
            RuleFn fn = options[alt0()];
            (this->*fn)(current);
        }
        current = rule.current();
        return current;
    }

    Rule* xhtmlCDATA(Rule *parent = nullptr) {
        UnparserRuleContext rule(this, "xhtmlCDATA", parent);
        Rule* current = rule.current();
        CDATA(current);
        return current;
    }

    Rule* dtd(Rule *parent = nullptr) {
        UnparserRuleContext rule(this, "dtd", parent);
        Rule* current = rule.current();
        DTD(current);
        return current;
    }

    Rule* xml(Rule *parent = nullptr) {
        UnparserRuleContext rule(this, "xml", parent);
        Rule* current = rule.current();
        XML_DECLARATION(current);
        return current;
    }

    Rule* scriptlet(Rule *parent = nullptr) {
        UnparserRuleContext rule(this, "scriptlet", parent);
        Rule* current = rule.current();
        SCRIPTLET(current);
        return current;
    }

    Rule* script(Rule *parent = nullptr) {
        UnparserRuleContext rule(this, "script", parent);
        Rule* current = rule.current();
        _reserve(1, this, &HTMLGenerator::SCRIPT_OPEN, current);
        {
            AlternationContext alt0(rule, 0, HTMLGenerator::_alt_sizes[10], 0, HTMLGenerator::_alt_conds[0]);
            current = rule.current();
            std::vector<RuleFn> options{ &HTMLGenerator::SCRIPT_BODY, &HTMLGenerator::SCRIPT_SHORT_BODY };
            RuleFn fn = options[alt0()];
            (this->*fn)(current);
        }
        current = rule.current();
        return current;
    }

    Rule* style(Rule *parent = nullptr) {
        UnparserRuleContext rule(this, "style", parent);
        Rule* current = rule.current();
        _reserve(1, this, &HTMLGenerator::STYLE_OPEN, current);
        {
            AlternationContext alt0(rule, 0, HTMLGenerator::_alt_sizes[10], 0, HTMLGenerator::_alt_conds[0]);
            current = rule.current();
            std::vector<RuleFn> options{ &HTMLGenerator::STYLE_BODY, &HTMLGenerator::STYLE_SHORT_BODY };
            RuleFn fn = options[alt0()];
            (this->*fn)(current);
        }
        current = rule.current();
        return current;
    }


    using RuleFn = Rule* (HTMLGenerator::*)(Rule *);

    inline static const std::string _default_rule = "htmlDocument";

    inline static const std::unordered_map<std::string, RuleFn> _rule_fns = {
        { "HTML_COMMENT", &HTMLGenerator::HTML_COMMENT },
        { "HTML_CONDITIONAL_COMMENT", &HTMLGenerator::HTML_CONDITIONAL_COMMENT },
        { "XML_DECLARATION", &HTMLGenerator::XML_DECLARATION },
        { "CDATA", &HTMLGenerator::CDATA },
        { "DTD", &HTMLGenerator::DTD },
        { "SCRIPTLET", &HTMLGenerator::SCRIPTLET },
        { "SEA_WS", &HTMLGenerator::SEA_WS },
        { "SCRIPT_OPEN", &HTMLGenerator::SCRIPT_OPEN },
        { "STYLE_OPEN", &HTMLGenerator::STYLE_OPEN },
        { "TAG_OPEN", &HTMLGenerator::TAG_OPEN },
        { "HTML_TEXT", &HTMLGenerator::HTML_TEXT },
        { "TAG_CLOSE", &HTMLGenerator::TAG_CLOSE },
        { "TAG_SLASH_CLOSE", &HTMLGenerator::TAG_SLASH_CLOSE },
        { "TAG_SLASH", &HTMLGenerator::TAG_SLASH },
        { "TAG_EQUALS", &HTMLGenerator::TAG_EQUALS },
        { "TAG_NAME", &HTMLGenerator::TAG_NAME },
        { "TAG_WHITESPACE", &HTMLGenerator::TAG_WHITESPACE },
        { "HEXDIGIT", &HTMLGenerator::HEXDIGIT },
        { "DIGIT", &HTMLGenerator::DIGIT },
        { "TAG_NameChar", &HTMLGenerator::TAG_NameChar },
        { "TAG_NameStartChar", &HTMLGenerator::TAG_NameStartChar },
        { "SCRIPT_BODY", &HTMLGenerator::SCRIPT_BODY },
        { "SCRIPT_SHORT_BODY", &HTMLGenerator::SCRIPT_SHORT_BODY },
        { "STYLE_BODY", &HTMLGenerator::STYLE_BODY },
        { "STYLE_SHORT_BODY", &HTMLGenerator::STYLE_SHORT_BODY },
        { "ATTVALUE_VALUE", &HTMLGenerator::ATTVALUE_VALUE },
        { "ATTRIBUTE", &HTMLGenerator::ATTRIBUTE },
        { "ATTCHAR", &HTMLGenerator::ATTCHAR },
        { "ATTCHARS", &HTMLGenerator::ATTCHARS },
        { "HEXCHARS", &HTMLGenerator::HEXCHARS },
        { "DECCHARS", &HTMLGenerator::DECCHARS },
        { "DOUBLE_QUOTE_STRING", &HTMLGenerator::DOUBLE_QUOTE_STRING },
        { "SINGLE_QUOTE_STRING", &HTMLGenerator::SINGLE_QUOTE_STRING },
        { "htmlDocument", &HTMLGenerator::htmlDocument },
        { "htmlElements", &HTMLGenerator::htmlElements },
        { "htmlElement", &HTMLGenerator::htmlElement },
        { "htmlContent", &HTMLGenerator::htmlContent },
        { "htmlAttribute", &HTMLGenerator::htmlAttribute },
        { "htmlAttributeName", &HTMLGenerator::htmlAttributeName },
        { "htmlAttributeValue", &HTMLGenerator::htmlAttributeValue },
        { "htmlTagName", &HTMLGenerator::htmlTagName },
        { "htmlChardata", &HTMLGenerator::htmlChardata },
        { "htmlMisc", &HTMLGenerator::htmlMisc },
        { "htmlComment", &HTMLGenerator::htmlComment },
        { "xhtmlCDATA", &HTMLGenerator::xhtmlCDATA },
        { "dtd", &HTMLGenerator::dtd },
        { "xml", &HTMLGenerator::xml },
        { "scriptlet", &HTMLGenerator::scriptlet },
        { "script", &HTMLGenerator::script },
        { "style", &HTMLGenerator::style },
    };

    inline static const std::unordered_map<std::string, RuleSize> _rule_sizes = {
        { "HTML_COMMENT", RuleSize(1, 1) },
        { "HTML_CONDITIONAL_COMMENT", RuleSize(1, 1) },
        { "XML_DECLARATION", RuleSize(1, 1) },
        { "CDATA", RuleSize(1, 1) },
        { "DTD", RuleSize(1, 1) },
        { "SCRIPTLET", RuleSize(1, 1) },
        { "SEA_WS", RuleSize(1, 1) },
        { "SCRIPT_OPEN", RuleSize(1, 1) },
        { "STYLE_OPEN", RuleSize(1, 1) },
        { "TAG_OPEN", RuleSize(1, 1) },
        { "HTML_TEXT", RuleSize(1, 1) },
        { "TAG_CLOSE", RuleSize(1, 1) },
        { "TAG_SLASH_CLOSE", RuleSize(1, 1) },
        { "TAG_SLASH", RuleSize(1, 1) },
        { "TAG_EQUALS", RuleSize(1, 1) },
        { "TAG_NAME", RuleSize(2, 2) },
        { "TAG_WHITESPACE", RuleSize(1, 1) },
        { "HEXDIGIT", RuleSize(1, 1) },
        { "DIGIT", RuleSize(1, 1) },
        { "TAG_NameChar", RuleSize(1, 1) },
        { "TAG_NameStartChar", RuleSize(1, 1) },
        { "SCRIPT_BODY", RuleSize(1, 1) },
        { "SCRIPT_SHORT_BODY", RuleSize(1, 1) },
        { "STYLE_BODY", RuleSize(1, 1) },
        { "STYLE_SHORT_BODY", RuleSize(1, 1) },
        { "ATTVALUE_VALUE", RuleSize(3, 3) },
        { "ATTRIBUTE", RuleSize(2, 2) },
        { "ATTCHAR", RuleSize(1, 1) },
        { "ATTCHARS", RuleSize(2, 2) },
        { "HEXCHARS", RuleSize(1, 1) },
        { "DECCHARS", RuleSize(1, 1) },
        { "DOUBLE_QUOTE_STRING", RuleSize(1, 1) },
        { "SINGLE_QUOTE_STRING", RuleSize(1, 1) },
        { "htmlDocument", RuleSize(1, 0) },
        { "htmlElements", RuleSize(4, 1) },
        { "htmlElement", RuleSize(3, 1) },
        { "htmlContent", RuleSize(1, 0) },
        { "htmlAttribute", RuleSize(4, 2) },
        { "htmlAttributeName", RuleSize(3, 2) },
        { "htmlAttributeValue", RuleSize(4, 3) },
        { "htmlTagName", RuleSize(3, 2) },
        { "htmlChardata", RuleSize(2, 1) },
        { "htmlMisc", RuleSize(2, 1) },
        { "htmlComment", RuleSize(2, 1) },
        { "xhtmlCDATA", RuleSize(2, 1) },
        { "dtd", RuleSize(2, 1) },
        { "xml", RuleSize(2, 1) },
        { "scriptlet", RuleSize(2, 1) },
        { "script", RuleSize(2, 2) },
        { "style", RuleSize(2, 2) },
    };

    inline static const std::vector<std::vector<RuleSize>> _alt_sizes = {
        { RuleSize(0, 0), RuleSize(0, 0) },  // 0
        { RuleSize(0, 0), RuleSize(0, 0), RuleSize(0, 0) },  // 1
        { RuleSize(1, 1), RuleSize(0, 0), RuleSize(0, 0), RuleSize(0, 0), RuleSize(1, 1), RuleSize(0, 0), RuleSize(0, 0), RuleSize(0, 0) },  // 2
        { RuleSize(0, 0), RuleSize(0, 0), RuleSize(0, 0), RuleSize(0, 0), RuleSize(0, 0), RuleSize(0, 0) },  // 3
        { RuleSize(1, 1), RuleSize(1, 1), RuleSize(2, 2), RuleSize(1, 1), RuleSize(1, 1) },  // 4
        { RuleSize(0, 0), RuleSize(0, 0), RuleSize(0, 0), RuleSize(0, 0), RuleSize(0, 0), RuleSize(0, 0), RuleSize(0, 0), RuleSize(0, 0), RuleSize(0, 0), RuleSize(0, 0), RuleSize(0, 0), RuleSize(0, 0) },  // 5
        { RuleSize(2, 1), RuleSize(1, 1) },  // 6
        { RuleSize(3, 9), RuleSize(3, 4), RuleSize(3, 4), RuleSize(2, 1), RuleSize(2, 2), RuleSize(2, 2) },  // 7
        { RuleSize(3, 1), RuleSize(2, 1), RuleSize(2, 1) },  // 8
        { RuleSize(4, 6), RuleSize(3, 2) },  // 9
        { RuleSize(1, 1), RuleSize(1, 1) },  // 10
    };

    inline static const std::vector<RuleSize> _quant_sizes = {
        RuleSize(0, 0),  // 0
        RuleSize(1, 1),  // 1
        RuleSize(2, 1),  // 2
        RuleSize(4, 1),  // 3
        RuleSize(4, 2),  // 4
    };

private:
    inline static const std::vector<std::vector<double>> _alt_conds = {
        { 1, 1 },  // 0
        { 1, 1, 1 },  // 1
        { 1, 1, 1, 1, 1, 1, 1, 1 },  // 2
        { 1, 1, 1, 1, 1, 1 },  // 3
        { 1, 1, 1, 1, 1 },  // 4
        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },  // 5
    };

    inline static const std::vector<std::vector<std::string>> _charsets = {
        Generator::_charset({ { 0x20, 0x7f } }),  // 0
        Generator::_charset({ { 0x20, 0x3c }, { 0x3d, 0x7f } }),  // 1
        Generator::_charset({ { 0x9, 0xa }, { 0xa, 0xb }, { 0xd, 0xe }, { 0x20, 0x21 } }),  // 2
        Generator::_charset({ { 0x30, 0x3a }, { 0x41, 0x47 }, { 0x61, 0x67 } }),  // 3
        Generator::_charset({ { 0x30, 0x3a } }),  // 4
        Generator::_charset({ { 0x300, 0x370 } }),  // 5
        Generator::_charset({ { 0x203f, 0x2041 } }),  // 6
        Generator::_charset({ { 0x3a, 0x3b }, { 0x41, 0x5b }, { 0x61, 0x7b } }),  // 7
        Generator::_charset({ { 0x2070, 0x2190 } }),  // 8
        Generator::_charset({ { 0x2c00, 0x2ff0 } }),  // 9
        Generator::_charset({ { 0x3001, 0xd800 } }),  // 10
        Generator::_charset({ { 0xf900, 0xfdd0 } }),  // 11
        Generator::_charset({ { 0xfdf0, 0xfffe } }),  // 12
        Generator::_charset({ { 0x20, 0x21 } }),  // 13
        Generator::_charset({ { 0x30, 0x3a }, { 0x41, 0x5b }, { 0x61, 0x7b } }),  // 14
        Generator::_charset({ { 0x20, 0x22 }, { 0x23, 0x3c }, { 0x3d, 0x7f } }),  // 15
        Generator::_charset({ { 0x20, 0x27 }, { 0x28, 0x3c }, { 0x3d, 0x7f } }),  // 16
    };

}; // class HTMLGenerator

#endif // GRAMMARINATOR_GENERATED_HTMLGENERATOR_HPP
